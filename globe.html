<!DOCTYPE html>
<html>
<head>
    <title>Globe</title>
    <style>
        body { 
            margin: 0; 
            padding: 0;
            overflow: hidden;
            height: 100vh; 
        }
        
        /* Different background options - uncomment one at a time */
        
        /* Original dark space */
        /* background: radial-gradient(circle, #111 0%, #000 100%); */
        
        /* Starfield */
        body {
            background: #000;
            background-image: 
                radial-gradient(circle at 20% 80%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 60% 80%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 10% 30%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 90% 70%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 30% 90%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 70% 10%, #ffffff 0%, transparent 50%);
            background-size: 3px 3px, 2px 2px, 1px 1px, 2px 2px, 1px 1px, 2px 2px, 1px 1px, 3px 3px;
        }
        
        /* Blue nebula - uncomment to use
        body {
            background: radial-gradient(circle at 30% 30%, rgba(148, 0, 211, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 70% 70%, rgba(255, 20, 147, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 20% 80%, rgba(0, 191, 255, 0.3) 0%, transparent 50%),
                        linear-gradient(45deg, #000428 0%, #004e92 100%);
        }
        */
        
        /* Sunset - uncomment to use
        body {
            background: linear-gradient(180deg, #ff7e5f 0%, #feb47b 50%, #ff6b6b 100%);
        }
        */
        
        /* Ocean - uncomment to use
        body {
            background: linear-gradient(180deg, #667db6 0%, #0082c8 50%, #667db6 100%);
        }
        */

        /* #globe background removed - sphere is now rendered with D3 */
        #globe {
            width: 100vw;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .land { 
            fill: #0066cc; 
            stroke: none; 
        }
        
        .city text {
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            -webkit-text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            -moz-text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        
        /* City navigation buttons */
        .city-nav {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .city-button {
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border: 2px solid #ff6b6b;
            border-radius: 25px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        .city-button:hover {
            background: rgba(255, 107, 107, 0.2);
            border-color: #fff;
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        
        .city-button.active {
            background: rgba(255, 107, 107, 0.9);
            border-color: #fff;
        }
    </style>
</head>
<body>
    <svg id="globe"></svg>
    
    <!-- City Navigation Buttons -->
    <div class="city-nav">
        <button class="city-button" id="montreal-btn">Montreal</button>
        <button class="city-button" id="moscow-btn">Moscow</button>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        const width = window.innerWidth;
        const height = window.innerHeight;
        const svg = d3.select('#globe')
            .attr('width', width)
            .attr('height', height);
        
        // Create projection with scale proportional to screen size
        const initialScale = Math.min(width, height) * 0.4;
        const projection = d3.geoOrthographic()
            .scale(initialScale)
            .center([0, 0])
            .rotate([0, -20])
            .translate([width / 2, height / 2]);
            
        const path = d3.geoPath().projection(projection);
        
        // Add sphere background
        const sphere = svg.append('path')
            .datum({ type: 'Sphere' })
            .attr('fill', '#001133')
            .attr('stroke', '#333')
            .attr('stroke-width', 1.5)
            .attr('d', path);
        
        // Load data
        d3.json('ne_110m_land.json')
            .then(function(world) {
                // Add land
                svg.selectAll('.land')
                    .data(world.features)
                    .enter()
                    .append('path')
                    .attr('class', 'land')
                    .attr('d', path);
                
                // Add city markers
                const cities = [
                    { name: "Montreal", coordinates: [-73.5673, 45.5017] },
                    { name: "Moscow", coordinates: [37.6176, 55.7558] }
                ];
                
                const cityMarkers = svg.selectAll('.city')
                    .data(cities)
                    .enter()
                    .append('g')
                    .attr('class', 'city');
                
                // Add city dots
                cityMarkers.append('circle')
                    .attr('r', 3)
                    .attr('fill', '#ff6b6b')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1);
                
                // Add city labels
                cityMarkers.append('text')
                    .attr('dx', 8)
                    .attr('dy', 4)
                    .attr('fill', '#fff')
                    .attr('font-family', 'Arial, sans-serif')
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .attr('text-shadow', '1px 1px 2px rgba(0,0,0,0.7)')
                    .text(d => d.name);
                
                function updateCityPositions() {
                    cityMarkers.each(function(d) {
                        const coords = projection(d.coordinates);
                        if (coords) {
                            d3.select(this)
                                .style('display', 'block')
                                .attr('transform', `translate(${coords[0]}, ${coords[1]})`);
                        } else {
                            // City is on the back side of the globe
                            d3.select(this).style('display', 'none');
                        }
                    });
                }
                
                // Initial city positioning
                updateCityPositions();
                
                // Animation variables
                let isAnimating = false;
                
                // Smooth animation function
                function animateToCity(cityName) {
                    if (isAnimating) return;
                    
                    const city = cities.find(c => c.name === cityName);
                    if (!city) return;
                    
                    isAnimating = true;
                    
                    // Update button states
                    document.querySelectorAll('.city-button').forEach(btn => btn.classList.remove('active'));
                    document.getElementById(cityName.toLowerCase() + '-btn').classList.add('active');
                    
                    // Target rotation to center the city
                    const targetRotation = [-city.coordinates[0], -city.coordinates[1]];
                    const targetScale = Math.min(width, height) * 1.5; // Zoom in nicely
                    
                    // Starting values
                    const startRotation = [...rotation];
                    const startScale = scale;
                    
                    // Animation duration and easing
                    const duration = 2000; // 2 seconds
                    const startTime = Date.now();
                    
                    function animate() {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Smooth easing function (ease-in-out)
                        const easeProgress = progress < 0.5 ? 
                            2 * progress * progress : 
                            1 - Math.pow(-2 * progress + 2, 3) / 2;
                        
                        // Interpolate rotation
                        rotation[0] = startRotation[0] + (targetRotation[0] - startRotation[0]) * easeProgress;
                        rotation[1] = startRotation[1] + (targetRotation[1] - startRotation[1]) * easeProgress;
                        
                        // Interpolate scale
                        scale = startScale + (targetScale - startScale) * easeProgress;
                        
                        // Apply changes
                        projection.rotate(rotation).scale(scale);
                        sphere.attr('d', path);
                        svg.selectAll('.land').attr('d', path);
                        updateCityPositions();
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            isAnimating = false;
                        }
                    }
                    
                    animate();
                }
                
                // Button event listeners
                document.getElementById('montreal-btn').addEventListener('click', () => {
                    animateToCity('Montreal');
                });
                
                document.getElementById('moscow-btn').addEventListener('click', () => {
                    animateToCity('Moscow');
                });
                
                // Controls
                let rotation = [0, -20];
                let scale = initialScale;
                
                // Mouse drag variables
                let isDragging = false;
                let lastMousePos = null;
                
                // Add wheel event listener for touchpad gestures
                svg.node().addEventListener('wheel', function(event) {
                    if (isAnimating) return; // Don't allow interactions during animation
                    event.preventDefault();
                    
                    // Vertical scrolling (deltaY) for zooming
                    if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {
                        const zoomFactor = event.deltaY > 0 ? 0.85 : 1.15; // Faster zoom
                        scale *= zoomFactor;
                        // Limit zoom range - MASSIVE scale for detailed geography
                        const minScale = Math.min(width, height) * 0.05;
                        const maxScale = Math.min(width, height) * 200; // 25x bigger max zoom!
                        scale = Math.max(minScale, Math.min(maxScale, scale));
                        projection.scale(scale);
                    }
                    
                    // Horizontal scrolling (deltaX) for rotation
                    if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {
                        const sensitivity = initialScale / scale; // Less sensitive when zoomed in
                        rotation[0] += event.deltaX * 0.3 * sensitivity;
                        projection.rotate(rotation);
                    }
                    
                    // Update the globe and sphere
                    sphere.attr('d', path);
                    svg.selectAll('.land').attr('d', path);
                    updateCityPositions();
                }, { passive: false });
                
                // Mouse drag controls
                svg.node().addEventListener('mousedown', function(event) {
                    if (isAnimating) return; // Don't allow drag during animation
                    isDragging = true;
                    lastMousePos = [event.clientX, event.clientY];
                    svg.style('cursor', 'grabbing');
                });
                
                svg.node().addEventListener('mousemove', function(event) {
                    if (!isDragging || !lastMousePos) return;
                    
                    const currentMousePos = [event.clientX, event.clientY];
                    const deltaX = currentMousePos[0] - lastMousePos[0];
                    const deltaY = currentMousePos[1] - lastMousePos[1];
                    
                    // Convert mouse movement to rotation with zoom-based sensitivity
                    const sensitivity = initialScale / scale; // Less sensitive when zoomed in
                    // Horizontal movement rotates around Y axis (longitude)
                    rotation[0] += deltaX * 0.5 * sensitivity;
                    // Vertical movement rotates around X axis (latitude)  
                    rotation[1] -= deltaY * 0.5 * sensitivity;
                    
                    // Clamp latitude rotation to prevent flipping
                    rotation[1] = Math.max(-90, Math.min(90, rotation[1]));
                    
                    projection.rotate(rotation);
                    sphere.attr('d', path);
                    svg.selectAll('.land').attr('d', path);
                    updateCityPositions();
                    
                    lastMousePos = currentMousePos;
                });
                
                svg.node().addEventListener('mouseup', function(event) {
                    isDragging = false;
                    lastMousePos = null;
                    svg.style('cursor', 'grab');
                });
                
                svg.node().addEventListener('mouseleave', function(event) {
                    isDragging = false;
                    lastMousePos = null;
                    svg.style('cursor', 'grab');
                });
                
                // Set initial cursor
                svg.style('cursor', 'grab');
                
                // Touch drag controls for mobile/tablet
                let lastTouchPos = null;
                
                svg.node().addEventListener('touchstart', function(event) {
                    if (isAnimating) return; // Don't allow touch during animation
                    event.preventDefault();
                    if (event.touches.length === 1) {
                        const touch = event.touches[0];
                        lastTouchPos = [touch.clientX, touch.clientY];
                    }
                }, { passive: false });
                
                svg.node().addEventListener('touchmove', function(event) {
                    event.preventDefault();
                    if (event.touches.length === 1 && lastTouchPos) {
                        const touch = event.touches[0];
                        const currentTouchPos = [touch.clientX, touch.clientY];
                        const deltaX = currentTouchPos[0] - lastTouchPos[0];
                        const deltaY = currentTouchPos[1] - lastTouchPos[1];
                        
                        // Convert touch movement to rotation with zoom-based sensitivity
                        const sensitivity = initialScale / scale; // Less sensitive when zoomed in
                        rotation[0] += deltaX * 0.5 * sensitivity;
                        rotation[1] -= deltaY * 0.5 * sensitivity;
                        
                        // Clamp latitude rotation
                        rotation[1] = Math.max(-90, Math.min(90, rotation[1]));
                        
                        projection.rotate(rotation);
                        sphere.attr('d', path);
                        svg.selectAll('.land').attr('d', path);
                        updateCityPositions();
                        
                        lastTouchPos = currentTouchPos;
                    }
                }, { passive: false });
                
                svg.node().addEventListener('touchend', function(event) {
                    lastTouchPos = null;
                });
                
                // Handle window resize
                window.addEventListener('resize', function() {
                    const newWidth = window.innerWidth;
                    const newHeight = window.innerHeight;
                    svg.attr('width', newWidth).attr('height', newHeight);
                    projection.translate([newWidth / 2, newHeight / 2]);
                    sphere.attr('d', path);
                    svg.selectAll('.land').attr('d', path);
                    updateCityPositions();
                });
                
            })
            .catch(function(error) {
                console.error('Error:', error);
            });
    </script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <title>Globe</title>
    <style>
        body { 
            margin: 0; 
            padding: 0;
            overflow: hidden;
            height: 100vh; 
        }
        
        /* Different background options - uncomment one at a time */
        
        /* Original dark space */
        /* background: radial-gradient(circle, #111 0%, #000 100%); */
        
        /* Starfield */
        body {
            background: #000;
            background-image: 
                radial-gradient(circle at 20% 80%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 60% 80%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 10% 30%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 90% 70%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 30% 90%, #ffffff 0%, transparent 50%),
                radial-gradient(circle at 70% 10%, #ffffff 0%, transparent 50%);
            background-size: 3px 3px, 2px 2px, 1px 1px, 2px 2px, 1px 1px, 2px 2px, 1px 1px, 3px 3px;
        }
        
        /* Blue nebula - uncomment to use
        body {
            background: radial-gradient(circle at 30% 30%, rgba(148, 0, 211, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 70% 70%, rgba(255, 20, 147, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 20% 80%, rgba(0, 191, 255, 0.3) 0%, transparent 50%),
                        linear-gradient(45deg, #000428 0%, #004e92 100%);
        }
        */
        
        /* Sunset - uncomment to use
        body {
            background: linear-gradient(180deg, #ff7e5f 0%, #feb47b 50%, #ff6b6b 100%);
        }
        */
        
        /* Ocean - uncomment to use
        body {
            background: linear-gradient(180deg, #667db6 0%, #0082c8 50%, #667db6 100%);
        }
        */

        /* #globe background removed - sphere is now rendered with D3 */
        #globe {
            width: 100vw;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .land { 
            fill: #0066cc; 
            stroke: none; 
        }
    </style>
</head>
<body>
    <svg id="globe"></svg>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        const width = window.innerWidth;
        const height = window.innerHeight;
        const svg = d3.select('#globe')
            .attr('width', width)
            .attr('height', height);
        
        // Create projection with scale proportional to screen size
        const initialScale = Math.min(width, height) * 0.4;
        const projection = d3.geoOrthographic()
            .scale(initialScale)
            .center([0, 0])
            .rotate([0, -20])
            .translate([width / 2, height / 2]);
            
        const path = d3.geoPath().projection(projection);
        
        // Add sphere background
        const sphere = svg.append('path')
            .datum({ type: 'Sphere' })
            .attr('fill', '#001133')
            .attr('stroke', '#333')
            .attr('stroke-width', 1.5)
            .attr('d', path);
        
        // Load data
        d3.json('ne_110m_land.json')
            .then(function(world) {
                // Add land
                svg.selectAll('.land')
                    .data(world.features)
                    .enter()
                    .append('path')
                    .attr('class', 'land')
                    .attr('d', path);
                
                // Controls
                let rotation = [0, -20];
                let scale = initialScale;
                
                // Mouse drag variables
                let isDragging = false;
                let lastMousePos = null;
                
                // Add wheel event listener for touchpad gestures
                svg.node().addEventListener('wheel', function(event) {
                    event.preventDefault();
                    
                    // Vertical scrolling (deltaY) for zooming
                    if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {
                        const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
                        scale *= zoomFactor;
                        // Limit zoom range - proportional to screen size
                        const minScale = Math.min(width, height) * 0.1;
                        const maxScale = Math.min(width, height) * 8;
                        scale = Math.max(minScale, Math.min(maxScale, scale));
                        projection.scale(scale);
                    }
                    
                    // Horizontal scrolling (deltaX) for rotation
                    if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {
                        rotation[0] += event.deltaX * 0.3;
                        projection.rotate(rotation);
                    }
                    
                    // Update the globe and sphere
                    sphere.attr('d', path);
                    svg.selectAll('.land').attr('d', path);
                }, { passive: false });
                
                // Mouse drag controls
                svg.node().addEventListener('mousedown', function(event) {
                    isDragging = true;
                    lastMousePos = [event.clientX, event.clientY];
                    svg.style('cursor', 'grabbing');
                });
                
                svg.node().addEventListener('mousemove', function(event) {
                    if (!isDragging || !lastMousePos) return;
                    
                    const currentMousePos = [event.clientX, event.clientY];
                    const deltaX = currentMousePos[0] - lastMousePos[0];
                    const deltaY = currentMousePos[1] - lastMousePos[1];
                    
                    // Convert mouse movement to rotation
                    // Horizontal movement rotates around Y axis (longitude)
                    rotation[0] += deltaX * 0.5;
                    // Vertical movement rotates around X axis (latitude)  
                    rotation[1] -= deltaY * 0.5;
                    
                    // Clamp latitude rotation to prevent flipping
                    rotation[1] = Math.max(-90, Math.min(90, rotation[1]));
                    
                    projection.rotate(rotation);
                    sphere.attr('d', path);
                    svg.selectAll('.land').attr('d', path);
                    
                    lastMousePos = currentMousePos;
                });
                
                svg.node().addEventListener('mouseup', function(event) {
                    isDragging = false;
                    lastMousePos = null;
                    svg.style('cursor', 'grab');
                });
                
                svg.node().addEventListener('mouseleave', function(event) {
                    isDragging = false;
                    lastMousePos = null;
                    svg.style('cursor', 'grab');
                });
                
                // Set initial cursor
                svg.style('cursor', 'grab');
                
                // Touch drag controls for mobile/tablet
                let lastTouchPos = null;
                
                svg.node().addEventListener('touchstart', function(event) {
                    event.preventDefault();
                    if (event.touches.length === 1) {
                        const touch = event.touches[0];
                        lastTouchPos = [touch.clientX, touch.clientY];
                    }
                }, { passive: false });
                
                svg.node().addEventListener('touchmove', function(event) {
                    event.preventDefault();
                    if (event.touches.length === 1 && lastTouchPos) {
                        const touch = event.touches[0];
                        const currentTouchPos = [touch.clientX, touch.clientY];
                        const deltaX = currentTouchPos[0] - lastTouchPos[0];
                        const deltaY = currentTouchPos[1] - lastTouchPos[1];
                        
                        // Convert touch movement to rotation
                        rotation[0] += deltaX * 0.5;
                        rotation[1] += deltaY * 0.5;
                        
                        // Clamp latitude rotation
                        rotation[1] = Math.max(-90, Math.min(90, rotation[1]));
                        
                        projection.rotate(rotation);
                        sphere.attr('d', path);
                        svg.selectAll('.land').attr('d', path);
                        
                        lastTouchPos = currentTouchPos;
                    }
                }, { passive: false });
                
                svg.node().addEventListener('touchend', function(event) {
                    lastTouchPos = null;
                });
                
                // Handle window resize
                window.addEventListener('resize', function() {
                    const newWidth = window.innerWidth;
                    const newHeight = window.innerHeight;
                    svg.attr('width', newWidth).attr('height', newHeight);
                    projection.translate([newWidth / 2, newHeight / 2]);
                    sphere.attr('d', path);
                    svg.selectAll('.land').attr('d', path);
                });
                
            })
            .catch(function(error) {
                console.error('Error:', error);
            });
    </script>
</body>
</html>